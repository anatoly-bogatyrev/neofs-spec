## Settlement and balances

Storage nodes get paid for implementing storage policy. Calculation is carried settlement which is the sum of all transmissions to each of the storage nodes. Preparation is made in several stages. They are

 - pay by audit results,
 - basic income,
 - pay by subnet.

At each stage, IR nodes send one transaction for every transfer. Balance contract collects signatures and transmit resources.

### Payment by audit results

Payment by audit result is made regarding the previous epoch when a new epoch starts. Calculations are made by Inner Ring alphabetic nodes. They form a table of transmissions below.

| Sender | Receiver | Amount |
| ----- | ---- | ----------- |
| 4e772f2f38612770233a2… | ee64ff861eec135f9f… | 0.0001 (FIXED12) |
| … | … | … |

The Amount value is established with the accuracy of the balance contract (FIXED12).

### Preliminary actions

They are to

 - Make a list of results of the previous epoch with the help of audit contract methods audit.ListByEpoch and audit.Get
 - Get the netmap of the previous epoch with the help of netmap contract method netmap.SnapshotByEpoch
 - Initialize internal table of funds transmissions

### Calculation

Calculation is made iteratively for every audit result:

 - Let us receive storage policy for a container audit of which has been made with the help of container contract method container.Get
 - Then we search for nodes taking part in storing this container and remove from the list those that belong to set fail_nodes  and do not belong to pass_nodes of the audit result.
 - Next, we obtain storage groups objects from list pass_sg. 

For each node let's calculate storage cost as follows:

$$
\frac{\sum_{i=1}^{k} SGSize_i}{2^{30}} \cdot NodePrice
$$

Price node attribute sets cost value for a gigabyte per epoch.

 - Then, we refresh the table. Sender-Receiver pairs shall be unique for the table.
`UPDATE Table SET AMOUNT = AMOUNT + Calculated WHERE SENDER = ContainerOwnerAddress AND RECEIVER = NodeAddress`
 - Finally, we scrutinize the table and process mutual transmissions (X->Y and Y->X). It may reduce the number of records in the table.

### Pay-out

Once a pay-out table is formed, an IR node sends a single transaction for each record in the transmission table.

### Storage node basic income

Basic income will ensure the network economy work with when it operates without storage groups. We do not guarantee safety and integrity of data in this case, but payment will be minimal.

Basic income is built on

 - rate for 1 GB defined by IR nodes (i.e. Committee) in network configuration,
 - information about the amount of stored data represented by storage nodes.

### Information collection on container capacity

To make basic income correlate to its load, we need a procedure to estimate container capacity. It is expensive either to conduct polls by IR nodes, or save data about each container on the side chain. Thus, the information is collected by storage nodes themselves, aggregated into containers, and sent to the audit contract.

### Container capacity statistics

During its whole lifespan, a storage node should record statistics on its load. Namely, it should display a list of containers it stores and data size corresponding to each of the containers. This information is recorded in the metabase or next to it.

### P2P information collection

Upon the notification of the side chain `container.StartEstimation` , nodes within a container share this information (regarding the results of th previous epoch). For each stored container location is figured out as per the previous netmap according to the determinatedly calculated seed:
`0x519C + LittleEndian(EpochNumber). `

First node of each SELECT is the synchronization point for the previous epoch. Container nodes dispatch information to it with a separate service NeoFS API. The request contains the number of the previous epoch, the container, and the size in bytes.

The receiving node can ignore the request if

 - the receiving node is not a synchronization point for the container of the previous epoch,
 - the sender is not a storage node of a container from the previous epoch,
 - the number of the epoch in the obtained report is far smaller or larger than expected (the expected value lies in the body of the event container.StartEstimation).

Event `container.StartEstimation` is generated by the contract of the container through collecting signatures of InnerRing nodes. They, in their turn, collect signatures to generate this event right after next epoch starts.

### Aggregation and record to side chain

The receiving node continues aggregate requests until it obtains notification container.StopEstimation. This event is also generated by a container contract for aggregating sufficient number of signatures by IR nodes.

IR nodes initialize the stop of aggregation of containers size approximately after ~1\5 of epoch. It is crucial that this event happens before IR starts calculating, so that nodes fulfill the memory of the contract with up-to-date information on time.

Aggregation is run through putting off the information received from the nodes not included in the 90th percentile as per the particular container and computation of the average storage size from the rest of the participants.

Then, the node signs KV pairs (key is container ID, V is the averaged value of data size on a single storage node) and sends them to the side chain

### Event map

![Container estimation](pic/estimation)

### Calculation of Inner Ring nodes pay-outs

An IR node calculates basic income in three stages. Each stage lasts for 1\3 of epoch, which are cut off against the height of the side chain.

#### Stage 1: looking for container size

At this stage, IR nodes do nothing, but events StartEstimation and StopEstimation should occur.  

#### Stage 2: transfer of funds to a common bank for payment

IR nodes go through the collected information on containers capacity. For each container the owner is figured out and the sum is calculated.

$$
\frac{AvgSize \cdot BaseRate}{2^{30}} \cdot NodesInContainer
$$

BaseRate is set by the Alphabet and defines basic cost of gigabyte per epoch.

This sum is refreshed in the table of transfers similar to the one from the settlement based on audit result. However, the receiver of the funds will be a 'box' account with a human-readable address known in advance.

Apart from the transmissions, the list of nodes on the network is filled in. For each container placement is built regarding the previous epoch, and a new value AvgSize is added to the node.

When all containers are processed, transactions should be sent into the network and the values from the network nodes table should be standardized.

#### Stage 3: transfer of assets from the common bank by storage nodes

Some transactions may fail due to insufficient funds of containers owners. Once 2\3 of an epoch comes, IR counts the funds collected in the 'box'. The aggregated sum should be distributed among all storage nodes according to the standardized values. An analogous table of transmissions is filled in, where the sender is the 'box' account, and the receiver is the storage nodes.

After the table is fulfilled, the system eliminates the nodes invalidated during the audit in the epoch before last or for any other reputation reasons.

Then, transmissions are sent.

### Event map

![Basic income](pic/basic_income)
